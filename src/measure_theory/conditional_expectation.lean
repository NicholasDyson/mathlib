/-
Copyright (c) 2021 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne
-/

import measure_theory.lp_space

/-! # Conditional expectation


-/

noncomputable theory
open topological_space measure_theory measure_theory.Lp filter
open_locale nnreal ennreal topological_space big_operators measure_theory

/-- Like `ae_measurable`, but the `measurable_space` structures used for the measurability
statement and for the measure are different.

TODO: change the definition of ae_measurable to use ae_measurable' ? -/
def ae_measurable' {Œ± Œ≤} [measurable_space Œ≤] (m : measurable_space Œ±) {m0 : measurable_space Œ±}
  (f : Œ± ‚Üí Œ≤) (Œº : measure Œ±) :
  Prop :=
‚àÉ g : Œ± ‚Üí Œ≤, @measurable Œ± Œ≤ m _ g ‚àß f =·µê[Œº] g

lemma measurable.ae_measurable' {Œ± Œ≤} [measurable_space Œ≤] {m m0 : measurable_space Œ±} {f : Œ± ‚Üí Œ≤}
  {Œº : measure Œ±} (hf : @measurable Œ± Œ≤ m _ f) :
  ae_measurable' m f Œº :=
‚ü®f, hf, eventually_eq.rfl‚ü©

namespace ae_measurable'

variables {Œ± Œ≤ : Type*} [measurable_space Œ≤] {f : Œ± ‚Üí Œ≤}

lemma mono {m2 m m0 : measurable_space Œ±} (hm : m2 ‚â§ m)
  {Œº : measure Œ±} (hf : ae_measurable' m2 f Œº) :
  ae_measurable' m f Œº :=
by { obtain ‚ü®g, hg_meas, hfg‚ü© := hf, exact ‚ü®g, measurable.mono hg_meas hm le_rfl, hfg‚ü©, }

lemma ae_measurable {m m0 : measurable_space Œ±} (hm : m ‚â§ m0)
  {Œº : measure Œ±} (hf : ae_measurable' m f Œº) :
  ae_measurable f Œº :=
ae_measurable'.mono hm hf

lemma ae_measurable'_of_ae_measurable'_trim {m m0 m0' : measurable_space Œ±} (hm0 : m0 ‚â§ m0')
  {Œº : measure Œ±} (hf : ae_measurable' m f (Œº.trim hm0)) :
  ae_measurable' m f Œº :=
by { obtain ‚ü®g, hg_meas, hfg‚ü© := hf, exact ‚ü®g, hg_meas, ae_eq_of_ae_eq_trim hfg‚ü©, }

lemma congr_ae {m m0 : measurable_space Œ±} {Œº : measure Œ±}
  {f g : Œ± ‚Üí Œ≤} (hf : ae_measurable' m f Œº) (hfg : f =·µê[Œº] g) :
  ae_measurable' m g Œº :=
by { obtain ‚ü®f', hf'_meas, hff'‚ü© := hf, exact ‚ü®f', hf'_meas, hfg.symm.trans hff'‚ü©, }

lemma add [has_add Œ≤] [has_measurable_add‚ÇÇ Œ≤] {m m0 : measurable_space Œ±}
  {Œº : measure Œ±} {f g : Œ± ‚Üí Œ≤} (hf : ae_measurable' m f Œº) (hg : ae_measurable' m g Œº) :
  ae_measurable' m (f+g) Œº :=
begin
  rcases hf with ‚ü®f', h_f'_meas, hff'‚ü©,
  rcases hg with ‚ü®g', h_g'_meas, hgg'‚ü©,
  refine ‚ü®f' + g', @measurable.add Œ± m _ _ _ _ f' g' h_f'_meas h_g'_meas, _‚ü©,
  exact hff'.add hgg',
end

lemma sub [add_group Œ≤] [has_measurable_sub‚ÇÇ Œ≤] {m m0 : measurable_space Œ±}
  {Œº : measure Œ±} {f g : Œ± ‚Üí Œ≤} (hf : ae_measurable' m f Œº) (hg : ae_measurable' m g Œº) :
  ae_measurable' m (f - g) Œº :=
begin
  rcases hf with ‚ü®f', h_f'_meas, hff'‚ü©,
  rcases hg with ‚ü®g', h_g'_meas, hgg'‚ü©,
  refine ‚ü®f' - g', @measurable.sub Œ± m _ _ _ _ f' g' h_f'_meas h_g'_meas, _‚ü©,
  exact hff'.sub hgg',
end

lemma neg [has_neg Œ≤] [has_measurable_neg Œ≤] {m m0 : measurable_space Œ±}
  {Œº : measure Œ±} {f : Œ± ‚Üí Œ≤} (hf : ae_measurable' m f Œº) :
  ae_measurable' m (-f) Œº :=
begin
  rcases hf with ‚ü®f', h_f'_meas, hff'‚ü©,
  exact ‚ü®-f', @measurable.neg Œ± m _ _ _ _ f' h_f'_meas, hff'.neg‚ü©,
end

lemma smul‚ÇÇ {Œ¥} [has_scalar Œ¥ Œ≤] [measurable_space Œ¥] [has_measurable_smul‚ÇÇ Œ¥ Œ≤]
  {m m0 : measurable_space Œ±} {Œº : measure Œ±}
  {f : Œ± ‚Üí Œ¥} (hf : ae_measurable' m f Œº) {g : Œ± ‚Üí Œ≤} (hg : ae_measurable' m g Œº) :
  ae_measurable' m (Œª x, f x ‚Ä¢ (g x)) Œº :=
begin
  obtain ‚ü®f', hf_meas, hff'‚ü© := hf,
  obtain ‚ü®g', hg_meas, hgg'‚ü© := hg,
  refine ‚ü®Œª x, (f' x) ‚Ä¢ (g' x), _, eventually_eq.comp‚ÇÇ hff' (Œª x y, x ‚Ä¢ y) hgg'‚ü©,
  exact @measurable.smul _ m _ _ _ _ _ _ _ _ hf_meas hg_meas,
end

lemma const_smul {Œ¥} [has_scalar Œ¥ Œ≤] [measurable_space Œ¥] [has_measurable_smul Œ¥ Œ≤]
  {m m0 : measurable_space Œ±} {Œº : measure Œ±} (c : Œ¥) {f : Œ± ‚Üí Œ≤} (hf : ae_measurable' m f Œº) :
  ae_measurable' m (c ‚Ä¢ f) Œº :=
begin
  rcases hf with ‚ü®f', h_f'_meas, hff'‚ü©,
  refine ‚ü®c ‚Ä¢ f', @measurable.const_smul Œ± m _ _ _ _ _ _ f' h_f'_meas c, _‚ü©,
  exact eventually_eq.fun_comp hff' (Œª x, c ‚Ä¢ x),
end

lemma restrict {m m0 : measurable_space Œ±} {Œº : measure Œ±} (hf : ae_measurable' m f Œº) (s : set Œ±) :
  ae_measurable' m f (Œº.restrict s) :=
by { obtain ‚ü®g, hg_meas, hfg‚ü© := hf, exact ‚ü®g, hg_meas, ae_restrict_of_ae hfg‚ü©, }

lemma indicator [has_zero Œ≤] {m m0 : measurable_space Œ±} {Œº : measure Œ±} (hf : ae_measurable' m f Œº)
  {s : set Œ±} (hs : @measurable_set Œ± m s) :
  ae_measurable' m (s.indicator f) Œº :=
begin
  rcases hf with ‚ü®f', h_f'_meas, hff'‚ü©,
  refine ‚ü®s.indicator f', @measurable.indicator Œ± _ m _ _ s _ h_f'_meas hs, _‚ü©,
  refine hff'.mono (Œª x hx, _),
  rw [set.indicator_apply, set.indicator_apply, hx],
end

lemma const {m m0 : measurable_space Œ±} {Œº : measure Œ±} (c : Œ≤) : ae_measurable' m (Œª x : Œ±, c) Œº :=
(@measurable_const _ _ _ m c).ae_measurable'

lemma smul_const {Œ¥} [has_scalar Œ¥ Œ≤] [measurable_space Œ¥] [has_measurable_smul‚ÇÇ Œ¥ Œ≤]
  {m m0 : measurable_space Œ±} {Œº : measure Œ±} {f : Œ± ‚Üí Œ¥} (hf : ae_measurable' m f Œº) (c : Œ≤) :
  ae_measurable' m (Œª x, f x ‚Ä¢ c) Œº :=
ae_measurable'.smul‚ÇÇ hf (const c)

end ae_measurable'

namespace measure_theory

variables {Œ± Œ≤ Œ≥ E E' F F' G G' H ùïú ùïÇ : Type*} {p : ‚Ñù‚â•0‚àû}
  [is_R_or_C ùïú] -- ùïú for ‚Ñù or ‚ÑÇ
  [is_R_or_C ùïÇ] [measurable_space ùïÇ] -- ùïÇ for ‚Ñù or ‚ÑÇ, together with a measurable_space
  [measurable_space Œ≤] -- Œ≤ for a generic measurable space
  -- F for Lp submodule
  [normed_group F] [normed_space ùïÇ F] [measurable_space F] [borel_space F]
  [second_countable_topology F]
  -- F' for integrals on F
  [normed_group F'] [normed_space ùïÇ F'] [measurable_space F'] [borel_space F']
  [second_countable_topology F'] [normed_space ‚Ñù F'] [complete_space F']
  -- G for Lp add_subgroup
  [normed_group G] [measurable_space G] [borel_space G] [second_countable_topology G]
  -- G' for integrals on G
  [normed_group G'] [measurable_space G'] [borel_space G'] [second_countable_topology G']
  [normed_space ‚Ñù G'] [complete_space G']
  -- H for measurable space and normed group (hypotheses of mem_‚Ñíp)
  [measurable_space H] [normed_group H]

section Lp_sub

variables (ùïÇ F)
/-- Lp subspace of functions `f` verifying `ae_measurable' m f Œº`. -/
def Lp_sub [opens_measurable_space ùïÇ] (m : measurable_space Œ±) [measurable_space Œ±] (p : ‚Ñù‚â•0‚àû)
  (Œº : measure Œ±) :
  submodule ùïÇ (Lp F p Œº) :=
{ carrier   := {f : (Lp F p Œº) | ae_measurable' m f Œº} ,
  zero_mem' := ‚ü®(0 : Œ± ‚Üí F), @measurable_zero _ Œ± _ m _, Lp.coe_fn_zero _ _ _‚ü©,
  add_mem'  := Œª f g hf hg, (hf.add hg).congr_ae (Lp.coe_fn_add f g).symm,
  smul_mem' := Œª c f hf, (hf.const_smul c).congr_ae (Lp.coe_fn_smul c f).symm, }
variables {ùïÇ F}

variables [opens_measurable_space ùïÇ]

lemma mem_Lp_sub_iff_ae_measurable' {m m0 : measurable_space Œ±} {Œº : measure Œ±} {f : Lp F p Œº} :
  f ‚àà Lp_sub F ùïÇ m p Œº ‚Üî ae_measurable' m f Œº :=
by simp_rw [‚Üê set_like.mem_coe, ‚Üê submodule.mem_carrier, Lp_sub, set.mem_set_of_eq]

lemma Lp_sub.ae_measurable' {m m0 : measurable_space Œ±} {Œº : measure Œ±} (f : Lp_sub F ùïÇ m p Œº) :
  ae_measurable' m f Œº :=
mem_Lp_sub_iff_ae_measurable'.mp f.mem

lemma mem_Lp_sub_self {m0 : measurable_space Œ±} (Œº : measure Œ±) (f : Lp F p Œº) :
  f ‚àà Lp_sub F ùïÇ m0 p Œº :=
mem_Lp_sub_iff_ae_measurable'.mpr (Lp.ae_measurable f)

lemma Lp_sub_coe {m m0 : measurable_space Œ±} {p : ‚Ñù‚â•0‚àû} {Œº : measure Œ±} {f : Lp_sub F ùïÇ m p Œº} :
  ‚áëf = (f : Lp F p Œº) :=
coe_fn_coe_base f

section complete_subspace

variables {Œπ : Type*} {m m0 : measurable_space Œ±} {Œº : measure Œ±}

lemma ae_measurable'_of_tendsto'_aux_mem_Lp (hm : m ‚â§ m0) (f : Œπ ‚Üí Lp G p Œº) (g : Œπ ‚Üí Œ± ‚Üí G)
  (hfg : ‚àÄ n, f n =·µê[Œº] g n) (hg : ‚àÄ n, @measurable Œ± _ m _ (g n)) (n : Œπ) :
  @mem_‚Ñíp Œ± G m _ _ (g n) p (Œº.trim hm) :=
begin
  refine ‚ü®@measurable.ae_measurable Œ± _ m _ _ _ (hg n), _‚ü©,
  have h_snorm_fg : @snorm Œ± _ m _ (g n) p (Œº.trim hm) = snorm (f n) p Œº,
    by { rw snorm_trim hm (hg n), exact snorm_congr_ae (hfg n).symm, },
  rw h_snorm_fg,
  exact Lp.snorm_lt_top (f n),
end

lemma ae_measurable'_of_tendsto'_aux_cauchy (hm : m ‚â§ m0) [nonempty Œπ] [semilattice_sup Œπ]
  [hp : fact (1 ‚â§ p)] (f : Œπ ‚Üí Lp G p Œº) (g : Œπ ‚Üí Œ± ‚Üí G) (hfg : ‚àÄ n, f n =·µê[Œº] g n)
  (hg : ‚àÄ n, @measurable Œ± _ m _ (g n)) (h_cauchy_seq : cauchy_seq f) :
  cauchy_seq (Œª n, @mem_‚Ñíp.to_Lp Œ± G m p _ _ _ _ _ (g n)
    (ae_measurable'_of_tendsto'_aux_mem_Lp hm f g hfg hg n)) :=
begin
  have mem_Lp_g : ‚àÄ n, @mem_‚Ñíp Œ± G m _ _ (g n) p (Œº.trim hm),
    from ae_measurable'_of_tendsto'_aux_mem_Lp hm f g hfg hg,
  let g_Lp := Œª n, @mem_‚Ñíp.to_Lp Œ± G m p _ _ _ _ _ (g n) (mem_Lp_g n),
  have h_g_ae_m := Œª n, @mem_‚Ñíp.coe_fn_to_Lp Œ± G m p _ _ _ _ _ _ (mem_Lp_g n),
  have h_cau_g : tendsto (Œª (n : Œπ √ó Œπ), snorm (g n.fst - g n.snd) p Œº) at_top (ùìù 0),
  { rw cauchy_seq_Lp_iff_cauchy_seq_‚Ñíp at h_cauchy_seq,
    suffices h_snorm_eq : ‚àÄ n : Œπ √ó Œπ, snorm (‚áë(f n.fst) - ‚áë(f n.snd)) p Œº
        = snorm (g n.fst - g n.snd) p Œº,
      by { simp_rw h_snorm_eq at h_cauchy_seq, exact h_cauchy_seq, },
    exact Œª n, snorm_congr_ae ((hfg n.fst).sub (hfg n.snd)), },
  have h_cau_g_m : tendsto (Œª (n : Œπ √ó Œπ), @snorm Œ± _ m _ (g n.fst - g n.snd) p (Œº.trim hm))
      at_top (ùìù 0),
    { suffices h_snorm_trim : ‚àÄ n : Œπ √ó Œπ, @snorm Œ± _ m _ (g n.fst - g n.snd) p (Œº.trim hm)
        = snorm (g n.fst - g n.snd) p Œº,
      { simp_rw h_snorm_trim, exact h_cau_g, },
      refine Œª n, snorm_trim _ _,
      exact @measurable.sub Œ± m _ _ _ _ (g n.fst) (g n.snd) (hg n.fst) (hg n.snd), },
  rw cauchy_seq_Lp_iff_cauchy_seq_‚Ñíp,
  suffices h_eq : ‚àÄ n : Œπ √ó Œπ, @snorm Œ± _ m _ ((g_Lp n.fst) - (g_Lp n.snd)) p (Œº.trim hm)
      = @snorm Œ± _ m _ (g n.fst - g n.snd) p (Œº.trim hm),
    by { simp_rw h_eq, exact h_cau_g_m, },
  exact Œª n, @snorm_congr_ae Œ± _ m _ _ _ _ _ ((h_g_ae_m n.fst).sub (h_g_ae_m n.snd)),
end

lemma ae_measurable'_of_tendsto' (hm : m ‚â§ m0) [nonempty Œπ] [semilattice_sup Œπ] [hp : fact (1 ‚â§ p)]
  [complete_space G] (f : Œπ ‚Üí Lp G p Œº) (g : Œπ ‚Üí Œ± ‚Üí G) (f_lim : Lp G p Œº)
  (hfg : ‚àÄ n, f n =·µê[Œº] g n) (hg : ‚àÄ n, @measurable Œ± _ m _ (g n))
  (h_tendsto : filter.at_top.tendsto f (ùìù f_lim)) :
  ae_measurable' m f_lim Œº :=
begin
  -- as sequence of functions of Lp, g is cauchy since f is.
  have mem_Lp_g : ‚àÄ n, @mem_‚Ñíp Œ± G m _ _ (g n) p (Œº.trim hm),
    from ae_measurable'_of_tendsto'_aux_mem_Lp hm f g hfg hg,
  let g_Lp := Œª n, @mem_‚Ñíp.to_Lp Œ± G m p _ _ _ _ _ (g n) (mem_Lp_g n),
  have h_g_ae_m := Œª n, @mem_‚Ñíp.coe_fn_to_Lp Œ± G m p _ _ _ _ _ _ (mem_Lp_g n),
  have h_cau_seq_g_Lp : cauchy_seq g_Lp,
    from ae_measurable'_of_tendsto'_aux_cauchy hm f g hfg hg h_tendsto.cauchy_seq,
  -- we now obtain a limit g_Lp_lim, which will be the measurable function used to prove
  -- `ae_measurable' m f_lim Œº`
  obtain ‚ü®g_Lp_lim, g_tendsto‚ü© := cauchy_seq_tendsto_of_complete h_cau_seq_g_Lp,
  have h_g_lim_meas_m : @measurable Œ± _ m _ g_Lp_lim,
    from @Lp.measurable Œ± G m p (Œº.trim hm) _ _ _ _ g_Lp_lim,
  refine ‚ü®g_Lp_lim, h_g_lim_meas_m, _‚ü©,
  -- the measurability part of `ae_measurable'` is ensured. Now we prove `f_lim =·µê[Œº] g_Lp_lim`
  have h_g_lim_meas : measurable g_Lp_lim, from h_g_lim_meas_m.mono hm le_rfl,
  rw tendsto_Lp_iff_tendsto_‚Ñíp' at g_tendsto h_tendsto,
  suffices h_snorm_zero : snorm (‚áëf_lim - ‚áëg_Lp_lim) p Œº = 0,
  { rw @snorm_eq_zero_iff Œ± G m0 p Œº _ _ _ _ _ (ennreal.zero_lt_one.trans_le hp.elim).ne.symm
      at h_snorm_zero,
    { have h_add_sub : ‚áëf_lim - ‚áëg_Lp_lim + ‚áëg_Lp_lim =·µê[Œº] 0 + ‚áëg_Lp_lim,
        from h_snorm_zero.add eventually_eq.rfl,
      simpa using h_add_sub, },
    { exact (Lp.ae_measurable f_lim).sub h_g_lim_meas.ae_measurable, }, },
  suffices sub_tendsto : tendsto (Œª (n : Œπ), snorm (‚áëf_lim - ‚áëg_Lp_lim) p Œº) at_top (ùìù 0),
    from tendsto_nhds_unique tendsto_const_nhds sub_tendsto,
  -- `g` tends to `f_lim` since it is equal to `f` and `f` tends to `f_lim`
  have h_tendsto' : tendsto (Œª (n : Œπ), snorm (g n - ‚áëf_lim) p Œº) at_top (ùìù 0),
  { suffices h_eq : ‚àÄ (n : Œπ), snorm (g n - ‚áëf_lim) p Œº = snorm (‚áë(f n) - ‚áëf_lim) p Œº,
      by { simp_rw h_eq, exact h_tendsto, },
    exact Œª n, snorm_congr_ae ((hfg n).symm.sub eventually_eq.rfl), },
  -- `g` tends to `g_Lp_lim` by definition of `g_Lp_lim`
  have g_tendsto' : tendsto (Œª (n : Œπ), snorm (g n - ‚áëg_Lp_lim) p Œº) at_top (ùìù 0),
  { suffices h_eq : ‚àÄ (n : Œπ), snorm (g n - ‚áëg_Lp_lim) p Œº
        = @snorm Œ± _ m _ (‚áë(g_Lp n) - ‚áëg_Lp_lim) p (Œº.trim hm),
      by { simp_rw h_eq, exact g_tendsto, },
    intro n,
    have h_eq_g : snorm (g n - ‚áëg_Lp_lim) p Œº = snorm (‚áë(g_Lp n) - ‚áëg_Lp_lim) p Œº,
      from snorm_congr_ae ((ae_eq_of_ae_eq_trim (h_g_ae_m n).symm).sub eventually_eq.rfl),
    rw h_eq_g,
    refine (snorm_trim hm _).symm,
    refine @measurable.sub Œ± m _ _ _ _ (g_Lp n) g_Lp_lim _ h_g_lim_meas_m,
    exact @Lp.measurable Œ± G m p (Œº.trim hm) _ _ _ _ (g_Lp n), },
  -- we now conclude that the two limits of `g` are equal
  let snorm_add := Œª (n : Œπ), snorm (g n - ‚áëf_lim) p Œº + snorm (g n - ‚áëg_Lp_lim) p Œº,
  have h_add_tendsto : tendsto snorm_add at_top (ùìù 0),
    by { rw ‚Üê add_zero (0 : ‚Ñù‚â•0‚àû), exact tendsto.add h_tendsto' g_tendsto', },
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds h_add_tendsto
    (Œª n, zero_le _) _,
  have h_add : (Œª n, snorm (f_lim - g_Lp_lim) p Œº)
      = Œª n, snorm (f_lim - g n + (g n - g_Lp_lim)) p Œº,
    by { ext1 n, congr, abel, },
  simp_rw h_add,
  refine Œª n, (snorm_add_le _ _ hp.elim).trans _,
  { exact ((Lp.measurable f_lim).sub ((hg n).mono hm le_rfl)).ae_measurable, },
  { exact (((hg n).mono hm le_rfl).sub h_g_lim_meas).ae_measurable, },
  refine add_le_add_right (le_of_eq _) _,
  rw [‚Üê neg_sub, snorm_neg],
end

lemma ae_measurable'_of_tendsto (hm : m ‚â§ m0) [nonempty Œπ] [semilattice_sup Œπ] [hp : fact (1 ‚â§ p)]
  [complete_space G] (f : Œπ ‚Üí Lp G p Œº) (hf : ‚àÄ n, ae_measurable' m (f n) Œº) (f_lim : Lp G p Œº)
  (h_tendsto : filter.at_top.tendsto f (ùìù f_lim)) :
  ae_measurable' m f_lim Œº :=
ae_measurable'_of_tendsto' hm f (Œª n, (hf n).some) f_lim (Œª n, (hf n).some_spec.2)
  (Œª n, (hf n).some_spec.1) h_tendsto

lemma is_seq_closed_ae_measurable' [complete_space G] (hm : m ‚â§ m0) [hp : fact (1 ‚â§ p)] :
  is_seq_closed {f : Lp G p Œº | ae_measurable' m f Œº} :=
is_seq_closed_of_def (Œª F f F_mem F_tendsto_f, ae_measurable'_of_tendsto hm F F_mem f F_tendsto_f)

lemma is_closed_ae_measurable' [complete_space G] (hm : m ‚â§ m0) [hp : fact (1 ‚â§ p)] :
  is_closed {f : Lp G p Œº | ae_measurable' m f Œº} :=
is_seq_closed_iff_is_closed.mp (is_seq_closed_ae_measurable' hm)

instance [hm : fact (m ‚â§ m0)] [complete_space F] [hp : fact (1 ‚â§ p)] :
  complete_space (Lp_sub F ùïÇ m p Œº) :=
is_closed.complete_space_coe (is_closed_ae_measurable' hm.elim)

end complete_subspace

end Lp_sub

end measure_theory
